________________________________________________________________________________		CS5004 Midterm -- Silicon Valley -- Prof Mark			Administered February 25, 2025________________________________________________________________________________			      MIDTERM EXAM RULES________________________________________________________________________________				       This is a proctored, in-person exam. You may use your laptop, the internet,Canvas, existing Piazza threads (but do not post during the exam!), materialsincluding slides from class, and your own notes. However, please do not copyand paste code from other sources that you have not written yourself, whetherfrom a website or a generative AI tool. It is fine to look things up such asthe name of a Java builtin class or the syntax for calling a particularmethod, to jog your memory. Accessing your own solutions to previousassignments is also fine.Please do not discuss the contents of this exam with anyone except theinstructor or the TAs before, during, or after taking the exam. One or twoclarification questions may be asked quietly. Please allow AT LEAST 10 MINUTESnear the end to commit and push your files to your GitHub repo, and upload theURL to Canvas, BEFORE the deadline. Late submissions will be severely penalized,since lateness provides an unfair advantage relative to other students.Modifying your code after the deadline is not OK, even if Canvas received yourURL on time. Both your pushed code and your Canvas-posted URL must be on time.________________________________________________________________________________				 INSTRUCTIONS________________________________________________________________________________This exam provides starter code. Please download the ".zip" file,uncompress it, and import the resulting folder hierarchy intoIntelliJ. (Keeping this ".txt" file in the folder is recommended.)There should be "src" and "test" folders as well. Use this command:		    File -> New Project From Existing SourcesYou may ask a TA or the instructor for help with this step, if needed. Somefiles are starter code requiring completion. You are working on parts of aMusic Playlist application. There are several tasks. One of the files,AbstractTune, deliberately contains bugs.WHAT TO DO:0. The following files must be understood, but you do NOT need to modify them:   Tune.java, Genre.java, Person.java, Mp3Tune.java, WavTune.java1. [20 points] Find FIVE bugs in AbstractTune.java. There may be more than five, but   you should report only five. Nearly identical bugs don't count. IntelliJ's yellow   warnings also do not count. Comment out buggy code. Add an extra line like this:   //BUG   to flag the bugs. Insert replacement code to fix the bugs. If you aren't sure or   lack time to fully correct a bug, add a comment describing the bug and your idea   for fixing it. Partial credit can be awarded even if you do not fully solve   the problem: finding a bug earns two points; fixing it earns up to four.2. [60 points] Implement the following unfinished code:    a. The compare method in TempoComparator.java    b. The compareTo method in AbstractTune.java    c. All unfinished methods in AbstractTune.java, including equals.    d. All unfinished Javadocs in AbstractTune.java    e. sortByTempo and sortByTitle in PlayList.java    f. Tests for those two sorting methods    g. All tests applicable to AbstractTune.java (except playTune)3. [20 points] Examine the three Class Diagrams provided, and answer the   following questions, by editing in your responses below after ">>>".       a. What is a good reason for a design such as  DiagramII, versus       the simpler version in DiagramI?    >>> II has a AbstractShape class which made the whole project easier to organize, since we can reuse the functions and methods we build. As consolidate all the method into AbstractShape, we can create new shapes easily by letting all the shapes inherit the functions and methods, instead of repeating everything again and again.         b. Try to infer what the "#" sign must mean in DiagramII. Why does this       matter?    >>> The "#" sign likely denotes protected visibility in UML (Unified Modeling Language). Protected members are accessible within the class itself and by subclasses but not by external classes. This matters because it indicates that certain methods or attributes are intended to be used or overridden by subclasses, which is crucial for inheritance and polymorphism.

Diagram II represents a class hierarchy for geometric shapes. Here's a breakdown:

Shape (Interface): This is an interface (or potentially an abstract class in some interpretations) defining the common methods all shapes must implement. These include calculating distance from the origin, area, perimeter, resizing, and comparing shapes.
Point2D (Class): Represents a point in a 2D space with x and y coordinates. It provides methods to access these coordinates and calculate the distance from the origin.
AbstractShape (Abstract Class): This class likely provides some default implementations or common attributes for shapes. It includes a reference (a Point2D object) and implementations for distOrOrigin() (likely a typo for distToOrigin()) and compareTo().
Circle (Class): Represents a circle with a center (Point2D) and radius. It implements the methods defined in the Shape interface.
Rectangle (Class): Represents a rectangle with a lowerLeft (Point2D), width, and height. It also implements the Shape interface.
The Meaning of "#"

The "#" symbol in front of reference in the AbstractShape class indicates that this attribute is protected.

What does "protected" mean?

In object-oriented programming, "protected" is an access modifier. It means that the reference attribute:

Is accessible within the AbstractShape class itself.
Is accessible by any subclass (child class) of AbstractShape (like Circle and Rectangle).
Is NOT directly accessible from outside the class hierarchy (i.e., by other unrelated classes).
Why Does This Matter?

The use of "protected" for the reference attribute is significant for several reasons:

Encapsulation and Data Hiding: It enforces encapsulation by preventing direct access to the reference from outside the class hierarchy. This protects the internal state of the AbstractShape and its subclasses.

Code Reusability and Inheritance: Subclasses like Circle and Rectangle can directly access and use the reference attribute without needing to implement their own copy. This promotes code reusability and simplifies inheritance.

Flexibility and Control: It allows the AbstractShape to manage a shared attribute (reference) that is relevant to all its subclasses, while still controlling access to it.

Potential for Default Behavior: The AbstractShape might use the reference to provide a default implementation of distToOrigin() or other methods that rely on a point of reference. Subclasses can then override these methods if they need different behavior.

In summary, the "#" symbol signifies "protected" access, which is a key concept in object-oriented programming that controls visibility and promotes good design principles like encapsulation and inheritance.

    c. Which links(s) in DiagramI should use a dark diamond arrowhead to       indicate a "has a" link?    >>> a Circle has a center which is a Point2D, so arrow head should be Point2D to Circle. a Rectangle has a lowerLeft which is a Point2D, so arrow head should be Point2D to Rectangle. 
        d. Which arrow in DiagramIII (x, y, or z) creates a "self-referential" structure?    >>> The arrow z in the ElementNode class creates a self-referential structure. A self-referential structure is a structure that contains a reference to itself. ElementNode has a rest attribute that refers to another 1List, which can be an ElementNode itself, which in turn could be another ElementNode (or an EmptyNode). This allows us to create a linked list structure where each element form recursive or self-referential relationship. x and y are inheritance relationships.



