________________________________________________________________________________		CS5004 Midterm -- Silicon Valley -- Prof Mark			Administered February 25, 2025________________________________________________________________________________			      MIDTERM EXAM RULES________________________________________________________________________________				       This is a proctored, in-person exam. You may use your laptop, the internet,Canvas, existing Piazza threads (but do not post during the exam!), materialsincluding slides from class, and your own notes. However, please do not copyand paste code from other sources that you have not written yourself, whetherfrom a website or a generative AI tool. It is fine to look things up such asthe name of a Java builtin class or the syntax for calling a particularmethod, to jog your memory. Accessing your own solutions to previousassignments is also fine.Please do not discuss the contents of this exam with anyone except theinstructor or the TAs before, during, or after taking the exam. One or twoclarification questions may be asked quietly. Please allow AT LEAST 10 MINUTESnear the end to commit and push your files to your GitHub repo, and upload theURL to Canvas, BEFORE the deadline. Late submissions will be severely penalized,since lateness provides an unfair advantage relative to other students.Modifying your code after the deadline is not OK, even if Canvas received yourURL on time. Both your pushed code and your Canvas-posted URL must be on time.________________________________________________________________________________				 INSTRUCTIONS________________________________________________________________________________This exam provides starter code. Please download the ".zip" file,uncompress it, and import the resulting folder hierarchy intoIntelliJ. (Keeping this ".txt" file in the folder is recommended.)There should be "src" and "test" folders as well. Use this command:		    File -> New Project From Existing SourcesYou may ask a TA or the instructor for help with this step, if needed. Somefiles are starter code requiring completion. You are working on parts of aMusic Playlist application. There are several tasks. One of the files,AbstractTune, deliberately contains bugs.WHAT TO DO:0. The following files must be understood, but you do NOT need to modify them:   Tune.java, Genre.java, Person.java, Mp3Tune.java, WavTune.java1. [20 points] Find FIVE bugs in AbstractTune.java. There may be more than five, but   you should report only five. Nearly identical bugs don't count. IntelliJ's yellow   warnings also do not count. Comment out buggy code. Add an extra line like this:   //BUG   to flag the bugs. Insert replacement code to fix the bugs. If you aren't sure or   lack time to fully correct a bug, add a comment describing the bug and your idea   for fixing it. Partial credit can be awarded even if you do not fully solve   the problem: finding a bug earns two points; fixing it earns up to four.2. [60 points] Implement the following unfinished code:    a. The compare method in TempoComparator.java    b. The compareTo method in AbstractTune.java    c. All unfinished methods in AbstractTune.java, including equals.    d. All unfinished Javadocs in AbstractTune.java    e. sortByTempo and sortByTitle in PlayList.java    f. Tests for those two sorting methods    g. All tests applicable to AbstractTune.java (except playTune)3. [20 points] Examine the three Class Diagrams provided, and answer the   following questions, by editing in your responses below after ">>>".       a. What is a good reason for a design such as  DiagramII, versus       the simpler version in DiagramI?    >>> II has a AbstractShape class which made the whole project easier to organize, since we can reuse the functions and methods we build. As consolidate all the method into AbstractShape, we can create new shapes easily by letting all the shapes inherit the functions and methods, instead of repeating everything again and again.         b. Try to infer what the "#" sign must mean in DiagramII. Why does this       matter?    >>> The "#" sign likely denotes protected visibility in UML (Unified Modeling Language). Protected members are accessible within the class itself and by subclasses but not by external classes. This matters because it indicates that certain methods or attributes are intended to be used or overridden by subclasses, which is crucial for inheritance and polymorphism.    c. Which links(s) in DiagramI should use a dark diamond arrowhead to       indicate a "has a" link?    >>> In DiagramI, the dark diamond arrowhead (indicating a "has a" or composition relationship) should be used for the links between:

Circle and Point2D (since a Circle has a center which is a Point2D).

Rectangle and Point2D (since a Rectangle has a lowerLeft which is a Point2D).        d. Which arrow in DiagramIII (x, y, or z) creates a "self-referential" structure?    >>> The arrow z in the ElementNode class creates a self-referential structure. This is because ElementNode has a rest attribute that refers to another 1List, which can be an ElementNode itself, creating a recursive or self-referential relationship. This is common in linked lists or similar data structures.

